---
title: JavaScript åŸç”Ÿæ™‚é–“æ—¥æœŸè™•ç†åº« - Temporal
description: æ·±å…¥äº†è§£ Temporal APIï¼šJavaScript æ™‚é–“è™•ç†çš„æœªä¾†æ¨™æº–
icon: Clock
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';
import { Files, File, Folder } from 'fumadocs-ui/components/files';

> æ¢ç´¢ JavaScript æ™‚é–“è™•ç†çš„æœªä¾†ï¼šTemporal API å®Œå…¨æŒ‡å—

JavaScript çš„ `Date` ç‰©ä»¶ä¸€ç›´æ˜¯é–‹ç™¼è€…çš„ç—›é»ï¼Œå……æ»¿äº†è¨­è¨ˆç¼ºé™·å’Œä½¿ç”¨é™·é˜±ã€‚**Temporal API** ä½œç‚º TC39 Stage 3 ææ¡ˆï¼Œæ—¨åœ¨è§£æ±ºæ‰€æœ‰é€™äº›å•é¡Œï¼Œç‚º JavaScript å¸¶ä¾†ç¾ä»£åŒ–çš„æ™‚é–“æ—¥æœŸè™•ç†èƒ½åŠ›ã€‚

## Temporal API ç°¡ä»‹

<Callout type="info">
Temporal API æ˜¯ JavaScript çš„æ–°ä¸€ä»£æ™‚é–“æ—¥æœŸè™•ç†æ¨™æº–ï¼Œç›®å‰è™•æ–¼ Stage 3 éšæ®µï¼Œé æœŸå°‡æˆç‚ºåŸç”Ÿæ”¯æ´çš„ API
</Callout>

### æ ¸å¿ƒç‰¹æ€§

<Steps>

<Step>
### ä¸å¯è®Šæ€§ (Immutability)
æ‰€æœ‰æ“ä½œéƒ½è¿”å›æ–°çš„å¯¦ä¾‹ï¼Œé¿å…æ„å¤–ä¿®æ”¹
</Step>

<Step>
### é«˜ç²¾åº¦æ”¯æŒ
æ”¯æ´ç´ç§’ç´šç²¾åº¦çš„æ™‚é–“è¨ˆç®—
</Step>

<Step>
### å®Œå–„çš„æ™‚å€æ”¯æŒ
å…§å»º IANA æ™‚å€æ•¸æ“šåº«æ”¯æŒ
</Step>

<Step>
### è±å¯Œçš„åŠŸèƒ½é›†
æä¾›å®Œæ•´çš„æ™‚é–“è¨ˆç®—ã€æ¯”è¼ƒã€æ ¼å¼åŒ–åŠŸèƒ½
</Step>

<Step>
### åš´æ ¼çš„å­—ç¬¦ä¸²æ ¼å¼
æ”¯æ´ ISO 8601 ç­‰æ¨™æº–æ ¼å¼
</Step>

<Step>
### éæ ¼é‡Œæ›†æ”¯æŒ
æ”¯æ´å¤šç¨®æ›†æ³•ç³»çµ±
</Step>

</Steps>

### å®‰è£èˆ‡ä½¿ç”¨

<Callout type="warn">
Temporal API ä»åœ¨å¯¦é©—éšæ®µï¼Œéœ€è¦ä½¿ç”¨ polyfill
</Callout>

```bash
# å®‰è£ Temporal polyfill
npm install @js-temporal/polyfill

# æˆ–ä½¿ç”¨ pnpm
pnpm add @js-temporal/polyfill
```

```javascript
// å°å…¥ Temporal polyfill
import { Temporal } from '@js-temporal/polyfill';

// ç¾åœ¨å¯ä»¥ä½¿ç”¨ Temporal API
const now = Temporal.Now.plainDateTimeISO();
console.log(now.toString()); // 2025-09-07T10:30:15
```

## æ ¸å¿ƒ API æ¦‚è¦½

### ä¸»è¦ç‰©ä»¶é¡å‹

<Tabs items={["Instant", "ZonedDateTime", "PlainDateTime", "PlainDate", "PlainTime"]}>

<Tab value="Instant">
```javascript
// Temporal.Instant - æ™‚é–“è»¸ä¸Šçš„ç²¾ç¢ºé»
const instant = Temporal.Now.instant();
console.log(instant.toString()); // 2025-09-07T10:30:15.123456789Z

// å¾ä¸åŒæ ¼å¼å‰µå»º
const fromString = Temporal.Instant.from('2025-09-07T10:30:15Z');
const fromEpoch = Temporal.Instant.fromEpochMilliseconds(Date.now());

// æ™‚é–“è¨ˆç®—
const later = instant.add({ hours: 2, minutes: 30 });
const earlier = instant.subtract({ days: 1 });

// æ¯”è¼ƒ
const isAfter = later.compare(instant) > 0; // true
const duration = later.since(instant);
console.log(duration.toString()); // PT2H30M

// æ ¼å¼åŒ–ï¼ˆéœ€è¦æ™‚å€ï¼‰
const formatted = instant.toZonedDateTimeISO('Asia/Taipei').toString();
console.log(formatted); // 2025-09-07T18:30:15.123456789+08:00[Asia/Taipei]
```

**ä½¿ç”¨å ´æ™¯ï¼š**
- UTC æ™‚é–“æˆ³å­˜å„²
- æœå‹™å™¨é–“æ™‚é–“åŒæ­¥
- ç²¾ç¢ºçš„æ™‚é–“é»è¨˜éŒ„
</Tab>

<Tab value="ZonedDateTime">
```javascript
// Temporal.ZonedDateTime - å¸¶æ™‚å€çš„å®Œæ•´æ—¥æœŸæ™‚é–“
const zdt = Temporal.Now.zonedDateTimeISO('Asia/Taipei');
console.log(zdt.toString()); // 2025-09-07T18:30:15.123+08:00[Asia/Taipei]

// å¾ä¸åŒæ™‚å€å‰µå»º
const tokyo = Temporal.ZonedDateTime.from({
  year: 2025,
  month: 9,
  day: 7,
  hour: 19,
  minute: 30,
  timeZone: 'Asia/Tokyo'
});

const newYork = tokyo.withTimeZone('America/New_York');
console.log(newYork.toString()); // è‡ªå‹•è½‰æ›æ™‚å€

// æ™‚å€ç›¸é—œæ“ä½œ
const offsetString = zdt.offset; // '+08:00'
const timeZoneName = zdt.timeZoneId; // 'Asia/Taipei'

// æ—¥æœŸæ™‚é–“æ“ä½œ
const nextWeek = zdt.add({ weeks: 1 });
const startOfDay = zdt.startOfDay();
const endOfMonth = zdt.with({ day: zdt.daysInMonth }).endOfDay();

// æœ¬åœ°åŒ–æ ¼å¼
const locale = 'zh-TW';
const formatted = zdt.toLocaleString(locale, {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  hour: '2-digit',
  minute: '2-digit'
});
console.log(formatted); // 2025å¹´9æœˆ7æ—¥ æ˜ŸæœŸæ—¥ ä¸‹åˆ6:30
```

**ä½¿ç”¨å ´æ™¯ï¼š**
- ç”¨æˆ¶ç•Œé¢é¡¯ç¤º
- é ç´„ç³»çµ±
- äº‹ä»¶æ’ç¨‹
</Tab>

<Tab value="PlainDateTime">
```javascript
// Temporal.PlainDateTime - ä¸å¸¶æ™‚å€çš„æ—¥æœŸæ™‚é–“
const pdt = Temporal.PlainDateTime.from('2025-09-07T14:30:15');
console.log(pdt.toString()); // 2025-09-07T14:30:15

// å‰µå»ºå’Œæ“ä½œ
const customDateTime = new Temporal.PlainDateTime(2025, 9, 7, 14, 30, 15);
const modified = pdt.with({ 
  hour: 16,
  minute: 0,
  second: 0 
});

// æå–çµ„ä»¶
const year = pdt.year;        // 2025
const month = pdt.month;      // 9
const dayOfWeek = pdt.dayOfWeek; // 7 (æ˜ŸæœŸæ—¥)
const dayOfYear = pdt.dayOfYear; // 250

// æ™‚é–“è¨ˆç®—
const duration = Temporal.Duration.from({ hours: 3, minutes: 45 });
const result = pdt.add(duration);

// è½‰æ›ç‚ºå¸¶æ™‚å€çš„æ™‚é–“
const zonedInTaipei = pdt.toZonedDateTime('Asia/Taipei');
const zonedInUTC = pdt.toZonedDateTime('UTC');

// æ¯”è¼ƒ
const another = Temporal.PlainDateTime.from('2025-09-07T16:00:00');
const comparison = pdt.until(another);
console.log(comparison.toString()); // PT1H30M
```

**ä½¿ç”¨å ´æ™¯ï¼š**
- è¡¨å–®è¼¸å…¥è™•ç†
- æœ¬åœ°æ™‚é–“è¨ˆç®—
- æ•¸æ“šåº«å­˜å„²ï¼ˆç„¡æ™‚å€ï¼‰
</Tab>

<Tab value="PlainDate">
```javascript
// Temporal.PlainDate - ç´”æ—¥æœŸï¼ˆç„¡æ™‚é–“ï¼‰
const date = Temporal.PlainDate.from('2025-09-07');
const today = Temporal.Now.plainDateISO();

// å‰µå»ºæ—¥æœŸ
const specificDate = new Temporal.PlainDate(2025, 12, 25); // è–èª•ç¯€
const fromObject = Temporal.PlainDate.from({ 
  year: 2025, 
  month: 9, 
  day: 7 
});

// æ—¥æœŸæ“ä½œ
const nextMonth = date.add({ months: 1 });
const lastYear = date.subtract({ years: 1 });
const startOfMonth = date.with({ day: 1 });
const endOfMonth = date.with({ day: date.daysInMonth });

// æ—¥æœŸå±¬æ€§
const dayOfWeek = date.dayOfWeek;    // 1-7 (é€±ä¸€åˆ°é€±æ—¥)
const weekOfYear = date.weekOfYear;  // 36
const isLeapYear = date.inLeapYear;  // false

// æ—¥æœŸæ¯”è¼ƒå’Œè¨ˆç®—
const birthday = Temporal.PlainDate.from('1990-05-15');
const age = today.since(birthday, { largestUnit: 'year' });
console.log(`å¹´é½¡: ${age.years} æ­²`);

// å·¥ä½œæ—¥è¨ˆç®—
function addBusinessDays(startDate, days) {
  let currentDate = startDate;
  let addedDays = 0;
  
  while (addedDays < days) {
    currentDate = currentDate.add({ days: 1 });
    // 1-5 è¡¨ç¤ºé€±ä¸€åˆ°é€±äº”
    if (currentDate.dayOfWeek <= 5) {
      addedDays++;
    }
  }
  
  return currentDate;
}

const workDate = addBusinessDays(date, 10);
console.log(`10å€‹å·¥ä½œæ—¥å¾Œ: ${workDate.toString()}`);
```

**ä½¿ç”¨å ´æ™¯ï¼š**
- ç”Ÿæ—¥ã€ç´€å¿µæ—¥
- å·¥ä½œæ—¥è¨ˆç®—
- æ—¥æ›†æ‡‰ç”¨
</Tab>

<Tab value="PlainTime">
```javascript
// Temporal.PlainTime - ç´”æ™‚é–“ï¼ˆç„¡æ—¥æœŸï¼‰
const time = Temporal.PlainTime.from('14:30:15.123');
const now = Temporal.Now.plainTimeISO();

// å‰µå»ºæ™‚é–“
const specificTime = new Temporal.PlainTime(14, 30, 15, 123, 456, 789);
const fromObject = Temporal.PlainTime.from({
  hour: 9,
  minute: 0,
  second: 0
});

// æ™‚é–“æ“ä½œ
const later = time.add({ hours: 2, minutes: 30 });
const earlier = time.subtract({ minutes: 15 });

// æ™‚é–“å±¬æ€§
const hour12 = time.hour > 12 ? time.hour - 12 : time.hour;
const isPM = time.hour >= 12;
const totalSeconds = time.hour * 3600 + time.minute * 60 + time.second;

// æ™‚é–“æ¯”è¼ƒ
const meetingStart = Temporal.PlainTime.from('09:00');
const meetingEnd = Temporal.PlainTime.from('10:30');
const meetingDuration = meetingEnd.since(meetingStart);
console.log(`æœƒè­°æ™‚é•·: ${meetingDuration.toString()}`); // PT1H30M

// æ™‚é–“ç¯„åœæª¢æŸ¥
function isWithinBusinessHours(time) {
  const start = Temporal.PlainTime.from('09:00');
  const end = Temporal.PlainTime.from('17:00');
  return time.compare(start) >= 0 && time.compare(end) <= 0;
}

console.log(isWithinBusinessHours(time)); // true/false

// æ ¼å¼åŒ–æ™‚é–“
const formatted = time.toLocaleString('zh-TW', {
  hour: '2-digit',
  minute: '2-digit',
  hour12: true
});
console.log(formatted); // ä¸‹åˆ2:30
```

**ä½¿ç”¨å ´æ™¯ï¼š**
- ç‡Ÿæ¥­æ™‚é–“è¨­å®š
- æé†’æ™‚é–“
- æ™‚é–“è¡¨ç®¡ç†
</Tab>

</Tabs>

## èˆ‡ç¾æœ‰æ–¹æ¡ˆæ¯”è¼ƒ

<Callout type="success">
Temporal API è§£æ±ºäº† Date ç‰©ä»¶å’Œç¬¬ä¸‰æ–¹åº«çš„è«¸å¤šå•é¡Œ
</Callout>

### JavaScript Date vs Temporal

<Tabs items={["å•é¡Œå°æ¯”", "API å°æ¯”", "æ•ˆèƒ½å°æ¯”"]}>

<Tab value="å•é¡Œå°æ¯”">
**JavaScript Date çš„å•é¡Œï¼š**

```javascript
// âŒ Date çš„å„ç¨®å•é¡Œ
const date = new Date();

// 1. å¯è®Šæ€§å•é¡Œ
date.setHours(10);
console.log(date); // åŸå§‹ç‰©ä»¶è¢«ä¿®æ”¹ï¼

// 2. æœˆä»½å¾ 0 é–‹å§‹
const confusingDate = new Date(2025, 8, 7); // å¯¦éš›æ˜¯ 9 æœˆ 7 æ—¥ï¼

// 3. æ™‚å€è™•ç†å›°é›£
const utc = new Date('2025-09-07T10:00:00Z');
const local = new Date('2025-09-07T10:00:00');
console.log(utc.getTime() === local.getTime()); // å¯èƒ½æ˜¯ false

// 4. å­—ç¬¦ä¸²è§£æä¸ä¸€è‡´
console.log(new Date('2025-09-07')); // å¯èƒ½è¢«è§£æç‚º UTC
console.log(new Date('2025/09/07')); // å¯èƒ½è¢«è§£æç‚ºæœ¬åœ°æ™‚é–“

// 5. è¨ˆç®—è¤‡é›œ
function addMonths(date, months) {
  // éœ€è¦è¤‡é›œçš„é‚è¼¯è™•ç†æœˆä»½å’Œå¹´ä»½è½‰æ›
  const newDate = new Date(date.getTime());
  newDate.setMonth(newDate.getMonth() + months);
  return newDate;
}
```

**âœ… Temporal çš„è§£æ±ºæ–¹æ¡ˆï¼š**

```javascript
// âœ… Temporal è§£æ±ºæ‰€æœ‰å•é¡Œ
// 1. ä¸å¯è®Šæ€§
const temporal = Temporal.Now.plainDateTimeISO();
const newTemporal = temporal.with({ hour: 10 }); // è¿”å›æ–°å¯¦ä¾‹

// 2. ç›´è§€çš„æœˆä»½
const clearDate = new Temporal.PlainDate(2025, 9, 7); // çœŸçš„æ˜¯ 9 æœˆ 7 æ—¥

// 3. æ˜ç¢ºçš„æ™‚å€è™•ç†
const utc = Temporal.Instant.from('2025-09-07T10:00:00Z');
const zoned = utc.toZonedDateTimeISO('Asia/Taipei');

// 4. ä¸€è‡´çš„å­—ç¬¦ä¸²è§£æ
const isoDate = Temporal.PlainDate.from('2025-09-07');
const isoDateTime = Temporal.PlainDateTime.from('2025-09-07T10:00:00');

// 5. ç°¡å–®çš„è¨ˆç®—
const result = temporal.add({ months: 6 }); // å°±é€™éº¼ç°¡å–®ï¼
```
</Tab>

<Tab value="API å°æ¯”">
**å¸¸è¦‹æ“ä½œå°æ¯”ï¼š**

```javascript
// ç²å–ç•¶å‰æ™‚é–“
// Date
const dateNow = new Date();

// Temporal
const temporalNow = Temporal.Now.plainDateTimeISO();

// å‰µå»ºç‰¹å®šæ™‚é–“
// Date
const dateSpecific = new Date(2025, 8, 7, 14, 30); // æ³¨æ„æœˆä»½ï¼

// Temporal  
const temporalSpecific = new Temporal.PlainDateTime(2025, 9, 7, 14, 30);

// æ™‚é–“åŠ æ³•
// Date
function addDays(date, days) {
  const result = new Date(date.getTime());
  result.setDate(result.getDate() + days);
  return result;
}

// Temporal
const result = temporal.add({ days: 7 });

// æ ¼å¼åŒ–
// Date
const formatted = dateNow.toLocaleDateString('zh-TW');

// Temporal
const formatted2 = temporalNow.toLocaleString('zh-TW');

// æ™‚å€è½‰æ›
// Date (è¤‡é›œä¸”å®¹æ˜“å‡ºéŒ¯)
function toTimezone(date, timezone) {
  // éœ€è¦è¤‡é›œçš„è¨ˆç®—...
}

// Temporal (ç°¡æ½”æ˜äº†)
const converted = zonedDateTime.withTimeZone('America/New_York');

// æ™‚é–“æ¯”è¼ƒ
// Date
const isAfter = date1.getTime() > date2.getTime();

// Temporal
const isAfter2 = temporal1.compare(temporal2) > 0;

// æ™‚é–“é–“éš”
// Date
const diff = Math.abs(date2.getTime() - date1.getTime());
const days = Math.floor(diff / (1000 * 60 * 60 * 24));

// Temporal
const duration = temporal2.since(temporal1);
const days2 = duration.days;
```
</Tab>

<Tab value="æ•ˆèƒ½å°æ¯”">
**æ•ˆèƒ½æ¸¬è©¦æ¯”è¼ƒï¼š**

```javascript
// æ•ˆèƒ½åŸºæº–æ¸¬è©¦
function benchmarkDateOperations() {
  const iterations = 100000;
  
  // Date æ“ä½œ
  console.time('Date operations');
  for (let i = 0; i < iterations; i++) {
    const date = new Date();
    const newDate = new Date(date.getTime());
    newDate.setDate(date.getDate() + 1);
    newDate.toISOString();
  }
  console.timeEnd('Date operations');
  
  // Temporal æ“ä½œ
  console.time('Temporal operations');
  for (let i = 0; i < iterations; i++) {
    const temporal = Temporal.Now.plainDateTimeISO();
    const newTemporal = temporal.add({ days: 1 });
    newTemporal.toString();
  }
  console.timeEnd('Temporal operations');
}

// è¨˜æ†¶é«”ä½¿ç”¨æ¯”è¼ƒ
function memoryUsageTest() {
  const dates = [];
  const temporals = [];
  
  console.time('Create 10000 Dates');
  for (let i = 0; i < 10000; i++) {
    dates.push(new Date());
  }
  console.timeEnd('Create 10000 Dates');
  
  console.time('Create 10000 Temporals');
  for (let i = 0; i < 10000; i++) {
    temporals.push(Temporal.Now.plainDateTimeISO());
  }
  console.timeEnd('Create 10000 Temporals');
}

// è¤‡é›œè¨ˆç®—æ¯”è¼ƒ
function complexCalculationBenchmark() {
  const startDate = new Date('2025-01-01');
  const startTemporal = Temporal.PlainDate.from('2025-01-01');
  
  console.time('Date: Add 365 days and format');
  let dateResult = startDate;
  for (let i = 0; i < 365; i++) {
    dateResult = new Date(dateResult.getTime() + 24 * 60 * 60 * 1000);
  }
  const dateFormatted = dateResult.toLocaleDateString();
  console.timeEnd('Date: Add 365 days and format');
  
  console.time('Temporal: Add 365 days and format');
  const temporalResult = startTemporal.add({ days: 365 });
  const temporalFormatted = temporalResult.toLocaleString();
  console.timeEnd('Temporal: Add 365 days and format');
  
  console.log('Results match:', dateFormatted === temporalFormatted);
}

// åŸ·è¡ŒåŸºæº–æ¸¬è©¦
benchmarkDateOperations();
memoryUsageTest();
complexCalculationBenchmark();
```

**çµæœåˆ†æï¼š**
- **Date**: å‰µå»ºé€Ÿåº¦å¿«ï¼Œä½†æ“ä½œè¤‡é›œä¸”å®¹æ˜“å‡ºéŒ¯
- **Temporal**: ç¨å¾®æ…¢ä¸€äº›ï¼Œä½† API æ›´æ¸…æ™°ã€æ›´å®‰å…¨
- **è¨˜æ†¶é«”**: Temporal å¯èƒ½ä½¿ç”¨æ›´å¤šè¨˜æ†¶é«”ï¼ˆåŒ…å«æ›´å¤šå…ƒæ•¸æ“šï¼‰
- **é–‹ç™¼æ•ˆç‡**: Temporal å¤§å¹…æå‡é–‹ç™¼æ•ˆç‡å’Œä»£ç¢¼å¯è®€æ€§
</Tab>

</Tabs>

## å¯¦éš›æ‡‰ç”¨æ¡ˆä¾‹

### 1. æ—¥æ›†æ‡‰ç”¨

<Files>
  <Folder name="calendar-app" defaultOpen>
    <File name="CalendarComponent.tsx">ä¸»æ—¥æ›†çµ„ä»¶</File>
    <File name="EventManager.ts">äº‹ä»¶ç®¡ç†å™¨</File>
    <File name="TimeZoneHandler.ts">æ™‚å€è™•ç†</File>
    <File name="DateUtils.ts">æ—¥æœŸå·¥å…·å‡½æ•¸</File>
  </Folder>
</Files>

```tsx
import { Temporal } from '@js-temporal/polyfill';
import { useState, useMemo, useCallback } from 'react';

interface CalendarEvent {
  id: string;
  title: string;
  start: Temporal.ZonedDateTime;
  end: Temporal.ZonedDateTime;
  timeZone: string;
  description?: string;
  recurring?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
    interval: number;
    until?: Temporal.PlainDate;
  };
}

function CalendarApp() {
  const [currentMonth, setCurrentMonth] = useState(
    () => Temporal.Now.plainDateISO()
  );
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [selectedTimeZone, setSelectedTimeZone] = useState('Asia/Taipei');

  // ç”Ÿæˆæœˆä»½çš„æ‰€æœ‰æ—¥æœŸ
  const monthDates = useMemo(() => {
    const firstDay = currentMonth.with({ day: 1 });
    const lastDay = currentMonth.with({ day: currentMonth.daysInMonth });
    const dates = [];

    // æ·»åŠ æœˆåˆå‰çš„æ—¥æœŸï¼ˆç”¨æ–¼å¡«å……é€±çš„é–‹å§‹ï¼‰
    const firstWeekday = firstDay.dayOfWeek; // 1-7 (Mon-Sun)
    for (let i = firstWeekday - 1; i > 0; i--) {
      dates.push(firstDay.subtract({ days: i }));
    }

    // æ·»åŠ ç•¶æœˆæ‰€æœ‰æ—¥æœŸ
    for (let day = 1; day <= currentMonth.daysInMonth; day++) {
      dates.push(firstDay.with({ day }));
    }

    // æ·»åŠ æœˆæœ«å¾Œçš„æ—¥æœŸï¼ˆå¡«å……é€±çš„çµæŸï¼‰
    const lastWeekday = lastDay.dayOfWeek;
    for (let i = 1; i <= 7 - lastWeekday; i++) {
      dates.push(lastDay.add({ days: i }));
    }

    return dates;
  }, [currentMonth]);

  // ç²å–ç‰¹å®šæ—¥æœŸçš„äº‹ä»¶
  const getEventsForDate = useCallback((date: Temporal.PlainDate) => {
    return events.filter(event => {
      const eventDate = event.start.withTimeZone(selectedTimeZone).toPlainDate();
      return eventDate.equals(date);
    });
  }, [events, selectedTimeZone]);

  // æ·»åŠ äº‹ä»¶
  const addEvent = useCallback((eventData: Omit<CalendarEvent, 'id'>) => {
    const newEvent: CalendarEvent = {
      ...eventData,
      id: crypto.randomUUID(),
    };
    setEvents(prev => [...prev, newEvent]);
  }, []);

  // è™•ç†é‡è¤‡äº‹ä»¶
  const generateRecurringEvents = useCallback((baseEvent: CalendarEvent) => {
    if (!baseEvent.recurring) return [baseEvent];

    const events = [baseEvent];
    const { frequency, interval, until } = baseEvent.recurring;
    let currentStart = baseEvent.start;
    
    while (!until || currentStart.toPlainDate().compare(until) <= 0) {
      // æ ¹æ“šé »ç‡è¨ˆç®—ä¸‹ä¸€å€‹äº‹ä»¶æ™‚é–“
      switch (frequency) {
        case 'daily':
          currentStart = currentStart.add({ days: interval });
          break;
        case 'weekly':
          currentStart = currentStart.add({ weeks: interval });
          break;
        case 'monthly':
          currentStart = currentStart.add({ months: interval });
          break;
        case 'yearly':
          currentStart = currentStart.add({ years: interval });
          break;
      }

      if (until && currentStart.toPlainDate().compare(until) > 0) break;

      const duration = baseEvent.end.since(baseEvent.start);
      const nextEnd = currentStart.add(duration);

      events.push({
        ...baseEvent,
        id: `${baseEvent.id}-${currentStart.toPlainDate().toString()}`,
        start: currentStart,
        end: nextEnd,
      });

      // é˜²æ­¢ç„¡é™è¿´åœˆ
      if (events.length > 100) break;
    }

    return events;
  }, []);

  // æœˆä»½å°èˆª
  const navigateMonth = useCallback((direction: 'prev' | 'next') => {
    setCurrentMonth(prev => 
      direction === 'prev' 
        ? prev.subtract({ months: 1 })
        : prev.add({ months: 1 })
    );
  }, []);

  // ä»Šæ—¥é«˜äº®
  const isToday = useCallback((date: Temporal.PlainDate) => {
    const today = Temporal.Now.plainDateISO();
    return date.equals(today);
  }, []);

  return (
    <div className="calendar-app">
      {/* æœˆä»½å°èˆª */}
      <div className="calendar-header">
        <button onClick={() => navigateMonth('prev')}>â€¹</button>
        <h2>{currentMonth.toLocaleString('zh-TW', { 
          year: 'numeric', 
          month: 'long' 
        })}</h2>
        <button onClick={() => navigateMonth('next')}>â€º</button>
      </div>

      {/* æ™‚å€é¸æ“‡ */}
      <div className="timezone-selector">
        <select 
          value={selectedTimeZone} 
          onChange={(e) => setSelectedTimeZone(e.target.value)}
        >
          <option value="Asia/Taipei">å°åŒ—æ™‚é–“</option>
          <option value="America/New_York">ç´ç´„æ™‚é–“</option>
          <option value="Europe/London">å€«æ•¦æ™‚é–“</option>
          <option value="Asia/Tokyo">æ±äº¬æ™‚é–“</option>
        </select>
      </div>

      {/* æ—¥æ›†ç¶²æ ¼ */}
      <div className="calendar-grid">
        {['é€±ä¸€', 'é€±äºŒ', 'é€±ä¸‰', 'é€±å››', 'é€±äº”', 'é€±å…­', 'é€±æ—¥'].map(day => (
          <div key={day} className="calendar-header-day">
            {day}
          </div>
        ))}
        
        {monthDates.map((date, index) => {
          const dayEvents = getEventsForDate(date);
          const isCurrentMonth = date.month === currentMonth.month;
          
          return (
            <div 
              key={index}
              className={`calendar-day ${isCurrentMonth ? 'current-month' : 'other-month'} ${isToday(date) ? 'today' : ''}`}
            >
              <span className="day-number">{date.day}</span>
              <div className="events">
                {dayEvents.slice(0, 3).map(event => (
                  <div key={event.id} className="event">
                    {event.title}
                  </div>
                ))}
                {dayEvents.length > 3 && (
                  <div className="more-events">
                    +{dayEvents.length - 3} æ›´å¤š
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>

      {/* äº‹ä»¶æ·»åŠ è¡¨å–® */}
      <EventForm onAddEvent={addEvent} defaultTimeZone={selectedTimeZone} />
    </div>
  );
}

// äº‹ä»¶è¡¨å–®çµ„ä»¶
function EventForm({ onAddEvent, defaultTimeZone }: {
  onAddEvent: (event: Omit<CalendarEvent, 'id'>) => void;
  defaultTimeZone: string;
}) {
  const [title, setTitle] = useState('');
  const [startDate, setStartDate] = useState('');
  const [startTime, setStartTime] = useState('');
  const [endDate, setEndDate] = useState('');
  const [endTime, setEndTime] = useState('');

  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      const start = Temporal.PlainDateTime
        .from(`${startDate}T${startTime}`)
        .toZonedDateTime(defaultTimeZone);
        
      const end = Temporal.PlainDateTime
        .from(`${endDate}T${endTime}`)
        .toZonedDateTime(defaultTimeZone);

      onAddEvent({
        title,
        start,
        end,
        timeZone: defaultTimeZone,
      });

      // é‡ç½®è¡¨å–®
      setTitle('');
      setStartDate('');
      setStartTime('');
      setEndDate('');
      setEndTime('');
    } catch (error) {
      console.error('Invalid date/time format:', error);
    }
  }, [title, startDate, startTime, endDate, endTime, defaultTimeZone, onAddEvent]);

  return (
    <form onSubmit={handleSubmit} className="event-form">
      <h3>æ·»åŠ äº‹ä»¶</h3>
      
      <input
        type="text"
        placeholder="äº‹ä»¶æ¨™é¡Œ"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        required
      />
      
      <div className="datetime-inputs">
        <div>
          <label>é–‹å§‹æ™‚é–“</label>
          <input
            type="date"
            value={startDate}
            onChange={(e) => setStartDate(e.target.value)}
            required
          />
          <input
            type="time"
            value={startTime}
            onChange={(e) => setStartTime(e.target.value)}
            required
          />
        </div>
        
        <div>
          <label>çµæŸæ™‚é–“</label>
          <input
            type="date"
            value={endDate}
            onChange={(e) => setEndDate(e.target.value)}
            required
          />
          <input
            type="time"
            value={endTime}
            onChange={(e) => setEndTime(e.target.value)}
            required
          />
        </div>
      </div>
      
      <button type="submit">æ·»åŠ äº‹ä»¶</button>
    </form>
  );
}
```

### 2. React Hooks æ•´åˆ

<Callout type="success">
å°‡ Temporal API å°è£ç‚ºå¯é‡ç”¨çš„ React Hooks
</Callout>

```tsx
import { Temporal } from '@js-temporal/polyfill';
import { useState, useEffect, useCallback, useMemo } from 'react';

// 1. ç•¶å‰æ™‚é–“ Hook
function useCurrentTime(updateInterval: number = 1000) {
  const [currentTime, setCurrentTime] = useState(() => 
    Temporal.Now.zonedDateTimeISO()
  );

  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(Temporal.Now.zonedDateTimeISO());
    }, updateInterval);

    return () => clearInterval(timer);
  }, [updateInterval]);

  return currentTime;
}

// 2. æ™‚å€è½‰æ› Hook
function useTimeZoneConverter() {
  const [sourceTimeZone, setSourceTimeZone] = useState('UTC');
  const [targetTimeZone, setTargetTimeZone] = useState('Asia/Taipei');

  const convertTime = useCallback((
    dateTime: string | Temporal.ZonedDateTime,
    from?: string,
    to?: string
  ) => {
    try {
      let zonedDateTime: Temporal.ZonedDateTime;
      
      if (typeof dateTime === 'string') {
        const plainDateTime = Temporal.PlainDateTime.from(dateTime);
        zonedDateTime = plainDateTime.toZonedDateTime(from || sourceTimeZone);
      } else {
        zonedDateTime = dateTime;
      }
      
      return zonedDateTime.withTimeZone(to || targetTimeZone);
    } catch (error) {
      console.error('Time conversion error:', error);
      return null;
    }
  }, [sourceTimeZone, targetTimeZone]);

  return {
    sourceTimeZone,
    targetTimeZone,
    setSourceTimeZone,
    setTargetTimeZone,
    convertTime,
  };
}

// 3. å€’è¨ˆæ™‚ Hook
function useCountdown(targetDate: Temporal.ZonedDateTime) {
  const [timeLeft, setTimeLeft] = useState(() => {
    const now = Temporal.Now.zonedDateTimeISO(targetDate.timeZoneId);
    return targetDate.since(now);
  });

  const [isExpired, setIsExpired] = useState(false);

  useEffect(() => {
    const timer = setInterval(() => {
      const now = Temporal.Now.zonedDateTimeISO(targetDate.timeZoneId);
      const remaining = targetDate.since(now);
      
      if (remaining.total({ unit: 'second' }) <= 0) {
        setIsExpired(true);
        setTimeLeft(Temporal.Duration.from({ seconds: 0 }));
        clearInterval(timer);
      } else {
        setTimeLeft(remaining);
      }
    }, 1000);

    return () => clearInterval(timer);
  }, [targetDate]);

  const formatTimeLeft = useCallback(() => {
    const totalSeconds = timeLeft.total({ unit: 'second' });
    
    if (totalSeconds <= 0) return 'å·²éæœŸ';
    
    const days = Math.floor(totalSeconds / (24 * 3600));
    const hours = Math.floor((totalSeconds % (24 * 3600)) / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);
    
    const parts = [];
    if (days > 0) parts.push(`${days}å¤©`);
    if (hours > 0) parts.push(`${hours}å°æ™‚`);
    if (minutes > 0) parts.push(`${minutes}åˆ†`);
    if (seconds > 0) parts.push(`${seconds}ç§’`);
    
    return parts.join(' ');
  }, [timeLeft]);

  return {
    timeLeft,
    isExpired,
    formatTimeLeft,
  };
}

// 4. ç‡Ÿæ¥­æ™‚é–“æª¢æŸ¥ Hook
interface BusinessHours {
  [day: string]: {
    open: Temporal.PlainTime;
    close: Temporal.PlainTime;
  } | null;
}

function useBusinessHours(businessHours: BusinessHours, timeZone: string = 'Asia/Taipei') {
  const currentTime = useCurrentTime(60000); // æ¯åˆ†é˜æ›´æ–°

  const isOpen = useMemo(() => {
    const now = currentTime.withTimeZone(timeZone);
    const dayOfWeek = now.dayOfWeek; // 1-7 (Mon-Sun)
    const dayNames = ['', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    const todaySchedule = businessHours[dayNames[dayOfWeek]];
    
    if (!todaySchedule) return false;
    
    const currentTime = now.toPlainTime();
    return currentTime.compare(todaySchedule.open) >= 0 && 
           currentTime.compare(todaySchedule.close) <= 0;
  }, [currentTime, businessHours, timeZone]);

  const nextOpenTime = useMemo(() => {
    if (isOpen) return null;
    
    const now = currentTime.withTimeZone(timeZone);
    
    // æª¢æŸ¥ä»Šå¤©æ˜¯å¦é‚„æœƒé–‹é–€
    const dayOfWeek = now.dayOfWeek;
    const dayNames = ['', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    const todaySchedule = businessHours[dayNames[dayOfWeek]];
    
    if (todaySchedule && now.toPlainTime().compare(todaySchedule.open) < 0) {
      // ä»Šå¤©é‚„æœƒé–‹é–€
      return now.toPlainDate().toZonedDateTime({
        timeZone,
        plainTime: todaySchedule.open
      });
    }
    
    // æŸ¥æ‰¾ä¸‹ä¸€å€‹ç‡Ÿæ¥­æ—¥
    for (let i = 1; i <= 7; i++) {
      const nextDay = now.add({ days: i });
      const nextDayOfWeek = nextDay.dayOfWeek;
      const nextDaySchedule = businessHours[dayNames[nextDayOfWeek]];
      
      if (nextDaySchedule) {
        return nextDay.toPlainDate().toZonedDateTime({
          timeZone,
          plainTime: nextDaySchedule.open
        });
      }
    }
    
    return null;
  }, [currentTime, businessHours, timeZone, isOpen]);

  return {
    isOpen,
    nextOpenTime,
    currentTime,
  };
}

// 5. ä½¿ç”¨ç¯„ä¾‹çµ„ä»¶
function BusinessStatusWidget() {
  const businessHours: BusinessHours = {
    monday: { 
      open: Temporal.PlainTime.from('09:00'), 
      close: Temporal.PlainTime.from('18:00') 
    },
    tuesday: { 
      open: Temporal.PlainTime.from('09:00'), 
      close: Temporal.PlainTime.from('18:00') 
    },
    wednesday: { 
      open: Temporal.PlainTime.from('09:00'), 
      close: Temporal.PlainTime.from('18:00') 
    },
    thursday: { 
      open: Temporal.PlainTime.from('09:00'), 
      close: Temporal.PlainTime.from('18:00') 
    },
    friday: { 
      open: Temporal.PlainTime.from('09:00'), 
      close: Temporal.PlainTime.from('18:00') 
    },
    saturday: null, // é€±å…­ä¸ç‡Ÿæ¥­
    sunday: null,   // é€±æ—¥ä¸ç‡Ÿæ¥­
  };

  const { isOpen, nextOpenTime, currentTime } = useBusinessHours(businessHours);
  
  // å€’è¨ˆæ™‚åˆ°ä¸‹ä¸€æ¬¡é–‹é–€
  const countdown = useCountdown(nextOpenTime || currentTime.add({ days: 1 }));

  return (
    <div className="business-status">
      <h3>ç‡Ÿæ¥­ç‹€æ…‹</h3>
      <div className={`status ${isOpen ? 'open' : 'closed'}`}>
        {isOpen ? 'ğŸŸ¢ ç‡Ÿæ¥­ä¸­' : 'ğŸ”´ å·²æ‰“çƒŠ'}
      </div>
      
      <div className="current-time">
        ç•¶å‰æ™‚é–“: {currentTime.toLocaleString('zh-TW', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        })}
      </div>
      
      {!isOpen && nextOpenTime && (
        <div className="next-open">
          ä¸‹æ¬¡ç‡Ÿæ¥­: {nextOpenTime.toLocaleString('zh-TW', {
            weekday: 'long',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })}
          <br />
          å€’è¨ˆæ™‚: {countdown.formatTimeLeft()}
        </div>
      )}
    </div>
  );
}

// 6. ä¸–ç•Œæ™‚é˜çµ„ä»¶
function WorldClock() {
  const { convertTime } = useTimeZoneConverter();
  const currentTime = useCurrentTime();
  
  const timeZones = [
    { name: 'å°åŒ—', zone: 'Asia/Taipei' },
    { name: 'æ±äº¬', zone: 'Asia/Tokyo' },
    { name: 'ç´ç´„', zone: 'America/New_York' },
    { name: 'å€«æ•¦', zone: 'Europe/London' },
    { name: 'å·´é»', zone: 'Europe/Paris' },
    { name: 'é›ªæ¢¨', zone: 'Australia/Sydney' },
  ];

  return (
    <div className="world-clock">
      <h3>ä¸–ç•Œæ™‚é˜</h3>
      <div className="clocks">
        {timeZones.map(({ name, zone }) => {
          const localTime = convertTime(currentTime, currentTime.timeZoneId, zone);
          
          return (
            <div key={zone} className="clock">
              <div className="city-name">{name}</div>
              <div className="time">
                {localTime?.toLocaleString('zh-TW', {
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: false
                })}
              </div>
              <div className="date">
                {localTime?.toLocaleString('zh-TW', {
                  month: 'short',
                  day: 'numeric',
                  weekday: 'short'
                })}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

## é·ç§»æŒ‡å—

<Callout type="warn">
å¾ç¾æœ‰çš„ Date æˆ–ç¬¬ä¸‰æ–¹åº«é·ç§»åˆ° Temporal éœ€è¦è¬¹æ…è¨ˆåŠƒ
</Callout>

### æ¼¸é€²å¼é·ç§»ç­–ç•¥

<Steps>

<Step>
### è©•ä¼°ç•¶å‰ä»£ç¢¼
è­˜åˆ¥æ‰€æœ‰æ™‚é–“ç›¸é—œçš„ä»£ç¢¼å’Œä¾è³´
</Step>

<Step>
### å‰µå»ºå·¥å…·å‡½æ•¸
å°è£ Temporal æ“ä½œï¼Œæä¾›çµ±ä¸€ä»‹é¢
</Step>

<Step>
### é€æ­¥æ›¿æ›
å¾ä½é¢¨éšªçš„åŠŸèƒ½é–‹å§‹ï¼Œé€æ­¥æ›¿æ›
</Step>

<Step>
### æ¸¬è©¦é©—è­‰
ç¢ºä¿é·ç§»å¾Œçš„åŠŸèƒ½è¡Œç‚ºä¸€è‡´
</Step>

</Steps>

### é·ç§»å·¥å…·å‡½æ•¸

```typescript
// é·ç§»è¼”åŠ©å·¥å…·
class TemporalMigrationHelper {
  // Date åˆ° Temporal çš„è½‰æ›
  static dateToTemporal(date: Date, timeZone: string = 'UTC'): Temporal.ZonedDateTime {
    const instant = Temporal.Instant.fromEpochMilliseconds(date.getTime());
    return instant.toZonedDateTimeISO(timeZone);
  }

  // Temporal åˆ° Date çš„è½‰æ›
  static temporalToDate(temporal: Temporal.ZonedDateTime): Date {
    return new Date(temporal.epochMilliseconds);
  }

  // æ¼¸é€²å¼æ›¿æ›çš„åŒ…è£å™¨
  static createDateWrapper(useTemporalInternally: boolean = false) {
    return {
      now(): Date | Temporal.ZonedDateTime {
        if (useTemporalInternally) {
          return Temporal.Now.zonedDateTimeISO();
        }
        return new Date();
      },

      add(
        date: Date | Temporal.ZonedDateTime, 
        amount: { days?: number; months?: number; years?: number }
      ): Date | Temporal.ZonedDateTime {
        if (useTemporalInternally) {
          const temporal = date instanceof Date 
            ? this.constructor.dateToTemporal(date)
            : date as Temporal.ZonedDateTime;
          return temporal.add(amount);
        } else {
          const jsDate = date instanceof Date 
            ? date 
            : this.constructor.temporalToDate(date as Temporal.ZonedDateTime);
          const result = new Date(jsDate.getTime());
          
          if (amount.days) result.setDate(result.getDate() + amount.days);
          if (amount.months) result.setMonth(result.getMonth() + amount.months);
          if (amount.years) result.setFullYear(result.getFullYear() + amount.years);
          
          return result;
        }
      }
    };
  }
}

// ä½¿ç”¨ç¯„ä¾‹
const dateHelper = TemporalMigrationHelper.createDateWrapper(
  process.env.USE_TEMPORAL === 'true'
);

const currentTime = dateHelper.now();
const nextWeek = dateHelper.add(currentTime, { days: 7 });
```

## æœ€ä½³å¯¦è¸å»ºè­°

<Callout type="success">
éµå¾ªé€™äº›æœ€ä½³å¯¦è¸ï¼Œèƒ½å¤ å……åˆ†ç™¼æ® Temporal API çš„å„ªå‹¢
</Callout>

### 1. é¸æ“‡åˆé©çš„ç‰©ä»¶é¡å‹

```javascript
// âœ… æ ¹æ“šä½¿ç”¨å ´æ™¯é¸æ“‡æ­£ç¢ºçš„é¡å‹
// éœ€è¦ç²¾ç¢ºçš„æ™‚é–“é»è¨˜éŒ„
const logTime = Temporal.Now.instant();

// ç”¨æˆ¶ç•Œé¢é¡¯ç¤º
const displayTime = Temporal.Now.zonedDateTimeISO('Asia/Taipei');

// ç´”æ—¥æœŸæ“ä½œï¼ˆç”Ÿæ—¥ã€ç¯€æ—¥ï¼‰
const birthday = Temporal.PlainDate.from('1990-05-15');

// ç´”æ™‚é–“æ“ä½œï¼ˆç‡Ÿæ¥­æ™‚é–“ã€æé†’ï¼‰
const openTime = Temporal.PlainTime.from('09:00');

// æœ¬åœ°æ™‚é–“è¨ˆç®—ï¼ˆç„¡éœ€æ™‚å€ï¼‰
const appointment = Temporal.PlainDateTime.from('2025-09-07T14:30');
```

### 2. æ­£ç¢ºè™•ç†æ™‚å€

```javascript
// âœ… æ˜ç¢ºæŒ‡å®šæ™‚å€
const meeting = Temporal.PlainDateTime
  .from('2025-09-07T14:00')
  .toZonedDateTime('Asia/Taipei');

// âœ… æ™‚å€è½‰æ›
const meetingInNY = meeting.withTimeZone('America/New_York');

// âœ… é¿å…æ™‚å€é™·é˜±
function scheduleRecurringMeeting(
  startTime: Temporal.PlainDateTime,
  timeZone: string,
  recurrence: 'weekly' | 'monthly'
) {
  const meetings = [];
  let current = startTime.toZonedDateTime(timeZone);
  
  for (let i = 0; i < 10; i++) {
    meetings.push(current);
    current = recurrence === 'weekly'
      ? current.add({ weeks: 1 })
      : current.add({ months: 1 });
  }
  
  return meetings;
}
```

### 3. æ•ˆèƒ½å„ªåŒ–

```javascript
// âœ… é‡ç”¨ Temporal å¯¦ä¾‹
class DateCache {
  private cache = new Map<string, Temporal.ZonedDateTime>();
  
  getDateTime(isoString: string, timeZone: string): Temporal.ZonedDateTime {
    const key = `${isoString}-${timeZone}`;
    
    if (!this.cache.has(key)) {
      const dateTime = Temporal.Instant
        .from(isoString)
        .toZonedDateTimeISO(timeZone);
      this.cache.set(key, dateTime);
    }
    
    return this.cache.get(key)!;
  }
}

// âœ… æ‰¹é‡æ“ä½œå„ªåŒ–
function processTimeData(timestamps: string[]) {
  const processed = timestamps.map(ts => {
    const instant = Temporal.Instant.from(ts);
    return {
      utc: instant,
      taipei: instant.toZonedDateTimeISO('Asia/Taipei'),
      tokyo: instant.toZonedDateTimeISO('Asia/Tokyo')
    };
  });
  
  return processed;
}
```

## çµè«–èˆ‡å±•æœ›

<Callout type="info">
Temporal API ä»£è¡¨äº† JavaScript æ™‚é–“è™•ç†çš„æœªä¾†ï¼Œå€¼å¾—é–‹ç™¼è€…æå‰å­¸ç¿’å’Œæ¡ç”¨
</Callout>

### æ ¸å¿ƒå„ªå‹¢ç¸½çµ

1. **é¡å‹å®‰å…¨**: æ˜ç¢ºçš„ API è¨­è¨ˆæ¸›å°‘éŒ¯èª¤
2. **ä¸å¯è®Šæ€§**: é¿å…æ„å¤–ä¿®æ”¹å¸¶ä¾†çš„å•é¡Œ
3. **åœ‹éš›åŒ–æ”¯æŒ**: å®Œå–„çš„æ™‚å€å’Œæœ¬åœ°åŒ–åŠŸèƒ½
4. **ç¾ä»£åŒ–è¨­è¨ˆ**: ç¬¦åˆç¾ä»£ JavaScript é–‹ç™¼ç¿’æ…£

### æ¡ç”¨å»ºè­°

- **æ–°å°ˆæ¡ˆ**: å»ºè­°ç›´æ¥ä½¿ç”¨ Temporal API
- **ç¾æœ‰å°ˆæ¡ˆ**: å¯ä»¥æ¼¸é€²å¼é·ç§»ï¼Œå¾æ–°åŠŸèƒ½é–‹å§‹
- **å­¸ç¿’æŠ•è³‡**: æå‰æŒæ¡å°‡åœ¨æœªä¾†æˆç‚ºæ¨™æº–çš„æŠ€è¡“

### æœªä¾†ç™¼å±•

éš¨è‘— Temporal API é€²å…¥ Stage 4 ä¸¦è¢«ç€è¦½å™¨åŸç”Ÿæ”¯æ´ï¼Œå®ƒå°‡æˆç‚º JavaScript æ™‚é–“è™•ç†çš„æ¨™æº–æ–¹æ¡ˆã€‚ç¾åœ¨å­¸ç¿’å’Œæ¡ç”¨ Temporalï¼Œèƒ½å¤ è®“ä½ åœ¨é€™å€‹è½‰è®Šä¸­ä½”å¾—å…ˆæ©Ÿï¼Œå¯«å‡ºæ›´å¯é ã€æ›´æ˜“ç¶­è­·çš„æ™‚é–“è™•ç†ä»£ç¢¼ã€‚

JavaScript çš„æ™‚é–“è™•ç†çµ‚æ–¼è¦è¿ä¾†æ˜¥å¤©äº†ï¼ğŸŒ…